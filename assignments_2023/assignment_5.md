###### Практична робота №5
## Можливо, ви мали на увазі..?

### Мета роботи:
Попрактикуватись в задачах, що вирішуються методом динамічного програмування; реалізувати просту програму виправлення помилок у написанні слів

## Що будемо робити?
Ми всі звикли, що фактично будь-яке текстове поле для вводу, чи то цілий текстовий документ в редакторі, чи просто створення нового посту в інстаграмі супроводжується перевіркою граматики - неправильні слова підкреслюються та надаються рекомендації по виправленню. 

![](./../res/spell.png)

В цій роботі ми створимо просту систему, що буде здатна знаходити та виправляти помилки у написанні слів. Завдання буде складатися з двох частин: проста, підготовча частина, за яку можна отримати бали тільки в першій тиждень (перші два практичних заняття), та основна частина.

## Порядок виконання
### Підготовка
0. Прочитайте 9 розділ підручника Grokking Algorithms, щоб освіжити знання про динамічне програмування, особливо частину про знаходження найбільшого спільного підрядка та послідовності.
1. Скачайте [підготовлений список англійських слів](./../res/words_list.txt). Це один з так званих SCOWL - [Spell Checker Oriented Word Lists](http://wordlist.aspell.net/), тобто спеціально підготовлених списків слів саме для використання в якості бази для перевірки написання.
2. Напишіть просту консольну програму, що зчитує у користувача довільне речення (все до натискання клавіші `Enter`). Розбийте речення на слова, виключіть пунктуаційні знаки, та перевірте кожне слово на входження у список. Для кожного слова, яке ви не знайшли, виведіть підказку на екран. Наприклад:
```C#
> Togay a have the greatest tahk!
< Looks like you have typos in next words: 'Togay', 'tahk'
```

### Пошук підказок
Тепер ми готові не просто підсвітити слова, яких немає в словнику, а спробувати знайти підказки для виправлення. Почнемо з простого:
1. Реалізуйте розглянутий на лекції алгоритм [Longest common subsequence](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem). Пам'ятайте - код копіпастити не можна! Прочитайте алгоритм, розберіть його ще раз та реалізуйте самостійно. Для кожного "невідомого" слова знайдіть 5 найкращих кандидатів та виводіть їх користувачу. Спробуйте підібрати приклади, коли використання цього алгоритму призведе до некоректних підказок.
2. Гарним способом знайти можливі варіанти виправлення є пошук edit distance двох рядків. За визначенням, це кількість модифікуючих операцій які необхідно зробити над одним рядком, щоб отримати інший. 

Підвидом, який ми будемо використовувати, є відстань Левенштейна, яка враховує операції вставки, заміни або видалення символів. Наприклад, відстань Левенштейна між рядками crate та flat - 3:`crate` -> `frate` (заміна `c` на `f`), `frate` -> `frat` (видалення `e`), `frat` -> `flat` (заміна `r` на `l`). Для знаходження відстані Левенштейна зазвичай використовується динамічне програмування.

Детальне пояснення концепції відстані Левенштейна та сам алгоритм [можна прочитати тут](https://medium.com/@ethannam/understanding-the-levenshtein-distance-equation-for-beginners-c4285a5604f0). Модифікуйте програму, так щоб виводити підказки використовуючи алгоритм Левенштейна.

Існує певна модифікації алгоритму, що дозволяє враховувати окрім наведених операцій (вставка, заміна, видалення), ще й перестановку місцями літер. Це дуже корисно для виправлення помилок, оскільки часто випадково виходить написати щось типу "Приівт!" замість "Привіт!". Для того щоб отримати повний бал за цю роботу знайдіть цю модифікацію та реалізуйте.

## Контрольні питання
- В чому суть методики динамічного програмування? Наведіть приклади відомих вам алгоритмів
- Які переваги має динамічне програмування перед рекурсією?
- Що таке відстань Левенштейна та як її порахувати?

## Оцінювання

Максимальний бал - 8:
- Підготовча частина - _1 бал_;
- Реалізація алгоритму Левенштейна - _2 бали_;
- Реалізація алгоритму, що враховує перестановки - _1 бал_;
- Теоретичні питання - _2 бали_;
- Виконання додаткового практичного завдання при здачі - _2 бали_;
