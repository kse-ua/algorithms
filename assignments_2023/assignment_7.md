###### Практична робота №7
## Можливо, ви мали на увазі..?

### Мета роботи:
Попрактикуватись в задачах, що вирішуються методом динамічного програмування; реалізувати просту програму виправлення помилок у написанні слів

## Що будемо робити?
Ми всі звикли, що фактично будь-яке текстове поле для вводу, чи то цілий текстовий документ в редакторі, чи просто створення нового посту в інстаграмі супроводжується перевіркою граматики - неправильні слова підкреслюються та надаються рекомендації по виправленню. 

![](./../res/spell.png)

В цій роботі ми створимо просту систему, що буде здатна знаходити та виправляти помилки у написанні слів. Як і в попередній роботі, у вас буде завдання з двох частин: проста, підготовча частина, за яку можна отримати бали тільки в першій тиждень, та основна частина.

## Порядок виконання
### Підготовка
0. Прочитайте 9 розділ підручника Grokking Algorithms, щоб освіжити знання про динамічне програмування, особливо частину про знаходження найбільшого спільного підрядка та послідовності.
1. Скачайте [підготовлений список англійських слів](./../res/words_list.txt). Це один з так званих SCOWL - [Spell Checker Oriented Word Lists](http://wordlist.aspell.net/), тобто спеціально підготовлених списків слів саме для використання в якості бази для перевірки написання.
2. Напишіть просту консольну програму, що зчитує у користувача довільне речення (все до натискання клавіші `Enter`). Розбийте речення на слова, виключіть пунктуаційні знаки, та перевірте кожне слово на входження у список. Для кожного слова, яке ви не знайшли, виведіть підказку на екран. Наприклад:
```C#
> Togay a have the greatest tahk!
< Looks like you have typos in next words: 'Togay', 'tahk'
```

### Пошук підказок
Тепер ми готові не просто підсвітити слова, яких немає в словнику, а спробувати знайти підказки для виправлення. Почнемо з простого:
1. Реалізуйте розглянутий на лекції алгоритм [Longest common subsequence](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem). Пам'ятайте - код копіпастити не можна! Прочитайте алгоритм, розберіть його ще раз та реалізуйте самостійно. Для кожного "невідомого" слова знайдіть 5 найкращих кандидатів та виводіть їх користувачу. Спробуйте підібрати приклади, коли використання цього алгоритму призведе до некоректних підказок.
2. Гарним способом знайти можливі варіанти виправлення є пошук edit distance двох рядків. За визначенням, це кількість модифікуючих операцій які необхідно зробити над одним рядком, щоб отримати інший. 

Підвидом, який ми будемо використовувати, є відстань Левенштейна, яка враховує операції вставки, заміни або видалення символів. Наприклад, відстань Левенштейна між рядками crate та flat - 4:`crate` -> `cate` (видалення `r`), `cate` -> `cat` (видалення `e`), `cat` -> `fat` (заміна c на f), `fat` -> `flat` (вставка l). Для знаходження відстані Левенштейна зазвичай використовується динамічне програмування.

Детальне пояснення концепції відстані Левенштейна та сам алгоритм [можна прочитати тут](https://medium.com/@ethannam/understanding-the-levenshtein-distance-equation-for-beginners-c4285a5604f0). Модифікуйте програму, так щоб виводити підказки використовуючи алгоритм Левенштейна.

Існує певна модифікації алгоритму, що дозволяє враховувати окрім наведених операцій (вставка, заміна, видалення), ще й перестановку місцями літер. Це дуже корисно для виправлення помилок, оскільки часто випадково виходить написати щось типу "Приівт!" замість "Привіт!". За додатковий бал знайдіть цю модифікацію та реалізуйте.

## Контрольні питання
- В чому суть методики динамічного програмування? Наведіть приклади відомих вам алгоритмів
- Які переваги має динамічне програмування перед рекурсією?
- Що таке відстань Левенштейна та як її порахувати?

## Оцінювання

Максимальний бал - 7 (+1 додатковий):
- Підготовча частина - _1 бал_;
- Реалізація алгоритму Левенштейна - _2 бали_;
- Реалізація алгоритму, що враховує перестановки - _+1 бал_;
- Теоретичні питання - _2 бали_;
- Виконання додаткового практичного завдання при здачі - _2 бали_;
